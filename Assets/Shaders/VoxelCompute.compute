// VoxelNoiseCompute.compute
#pragma kernel CSMain
#pragma kernel SetVoxel

#include "Ruri_Common_FractalLibrary.hlsl"

// 定义体素数据结构，32位打包存储：
// 低16位：texId， 接着8位：shapeId， 最后8位：metadata
struct VoxelData
{
    uint packed;
};
RWStructuredBuffer<VoxelData> asyncVoxelBuffer;

// CPU传入参数
int3 gridPosition;
int newVoxelType; 

int3 chunkPosition;
uint3 chunkSize;

// 硬编码参数，与 CPU 端体素生成保持一致
float4 _QuaternionJuliaC;
float _QuaternionJuliaPosW;

float SphereSDF(float3 pos, float3 center, float radius)
{
    return length(pos - center) - radius;
}
// 综合分形距离估计函数（未做修改）
// 此处仅使用 KleinianDE 函数（从 MandelbrotDE 获得的缩放影响）
// 你可以根据需要启用其他 DE 函数
float CombinedFractalDE(float3 fractalPos, float4 minFractalPos, float4 maxFractalPos)
{
    float minDistance = 99999.0;

    // 2D 曼德博集合 DE
    float2 mandelbrotPos;
    float mandelbrotDistance = MandelbrotDE(fractalPos.xy, 1, mandelbrotPos);
    
    // 四元数茱莉亚集合 DE
    float4 pos4D = float4(fractalPos, _QuaternionJuliaPosW);
    float4 c = _QuaternionJuliaC;
    float4 quaternionJuliaPos;
    float quaternionJuliaDistance = QuaternionJuliaDE(pos4D, c, 10, quaternionJuliaPos);

    // 茱莉亚集合 DE
    float3 juliaPos;
    float juliaDistance = JuliaDE(fractalPos, juliaPos);
    
    // Amazing Box DE
    float3 amazingBoxPos;
    float amazingBoxDistance = AmazingBoxDE(fractalPos, -1.5, 1.0, 10, amazingBoxPos);
    
    // Mandelbulb DE
    float3 mandelbulbPos;
    float mandelbulbDistance = MandelbulbDE(fractalPos, 10, 8.0, mandelbulbPos);
    
    // Menger 海绵 DE
    float3 mengerPos;
    float mengerDistance = MengerSpongeDE(fractalPos, mengerPos);
    
    // Sierpinski DE
    float3 sierpinskiPos;
    float sierpinskiDistance = SierpinskiDE(fractalPos, sierpinskiPos);
    
    // 克莱因群 DE（使用 MandelbrotPos 计算缩放影响）
    float3 kleinianPos;
    float kleinianDistance = KleinianDE(fractalPos * sqrt(length(mandelbrotPos)), minFractalPos, maxFractalPos, kleinianPos);
    
    float3 spherePos;
    float sphereDistance = SphereSDF(fractalPos, 0, 0.5);
    
    // 本示例仅使用克莱因群距离来决定体素状态，可根据需要叠加其他函数结果
    minDistance = min(minDistance, sphereDistance);

    return minDistance;
}

// 主体计算函数，每个线程组 4×4×4 个线程
[numthreads(4,4,4)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // 计算行主序索引
    int index = id.z + id.y * chunkSize.z + id.x * (chunkSize.y * chunkSize.z);

    // 计算世界坐标（与 CPU 同步使用整数坐标）
    int3 worldPos = int3(id) + (chunkPosition * chunkSize);
    
    // GPU 端坐标转换：采用与 CPU 相同缩放，不做旋转
    float3 fractalPos = float3(worldPos) / 90.0;

    // 固定区域参数（与 CPU 保持一致）
    float4 minFractalPos = float4(-0.3252, -0.7862, -0.0948, 0.678);
    float4 maxFractalPos = float4( 0.3457,  1.0218,  1.2215, 0.9);

    // 对于 Marching Cubes，需要连续的密度场——将距离反转得到密度
    float density = -CombinedFractalDE(fractalPos, minFractalPos, maxFractalPos);

    // 根据密度正负决定纹理——密度大于0时认为是固体（texId设为1），否则为空气
    uint texId = (density > 0.0) ? 1u : 0u;
    // 为了使用 Marching Cubes 体素生成，所有体素采用等值（Isosurface）形状，shapeId固定为0
    uint shapeId = 0u;

    // 限幅到[-1, 1]后映射为0~255之间的值，以便通过 Density = (metadata-128)/127还原
    density = clamp(density, -1.0, 1.0);
    uint metadata = (uint)(density * 127.0 + 128.0);
    
    // 打包成 32 位数据：低16位存 texId，接下来的8位存 shapeId，再接下来的8位存 metadata
    asyncVoxelBuffer[index].packed = (metadata << 24) | (shapeId << 16) | (texId & 0xFFFF);
}

// 设置单个体素函数，每个线程组1个线程
[numthreads(1,1,1)]
void SetVoxel (uint3 id : SV_DispatchThreadID)
{
    int index = gridPosition.z +
                gridPosition.y * chunkSize.z +
                gridPosition.x * (chunkSize.y * chunkSize.z);
    
    // 根据传入 newVoxelType，设置固体或空气，并构造打包数据
    // 固体：density取1（对应metadata = 1*127 + 128 = 255）; 空气：density取-1（对应metadata = -127 + 128 = 1）
    uint texId = (newVoxelType == 1) ? 1u : 0u;
    uint shapeId = 0u;
    uint metadata = (newVoxelType == 1) ? (uint)(1.0 * 127.0 + 128.0) : (uint)((-1.0) * 127.0 + 128.0);
    asyncVoxelBuffer[index].packed = (metadata << 24) | (shapeId << 16) | (texId & 0xFFFF);
}
