#pragma kernel CSMain

#include "Ruri_Common_FractalLibrary.hlsl"

struct Voxel
{
    int voxelID;
    uint metadata; // In HLSL, bool/byte aligns to 4 bytes, so we use uint. We only care about the first byte.
};
RWStructuredBuffer<Voxel> asyncVoxelBuffer;

int3 chunkPosition;
uint3 chunkSize;

// 硬编码
float4 _QuaternionJuliaC;
float _QuaternionJuliaPosW;

// 综合分形距离估计函数
float CombinedFractalDE(float3 fractalPos, float4 minFractalPos, float4 maxFractalPos)
{
    float minDistance = 99999;

    // 2D 曼德博集合 DE
    float2 mandelbrotPos;
    float mandelbrotDistance = MandelbrotDE(fractalPos.xy, 1, mandelbrotPos);
    
    // 四元数茱莉亚集合 DE
    float4 pos4D = float4(fractalPos, _QuaternionJuliaPosW);
    float4 c = _QuaternionJuliaC;
    float4 quaternionJuliaPos;
    float quaternionJuliaDistance = QuaternionJuliaDE(pos4D, c, 10, quaternionJuliaPos);

    // 茱莉亚集合 DE
    float3 juliaPos;
    float juliaDistance = JuliaDE(fractalPos, juliaPos);
    
    // Amazing Box DE
    float3 amazingBoxPos;
    float amazingBoxDistance = AmazingBoxDE(fractalPos, -1.5, 1.0, 10, amazingBoxPos);
    
    // Mandelbulb DE
    float3 mandelbulbPos;
    float mandelbulbDistance = MandelbulbDE(fractalPos, 10, 8.0, mandelbulbPos);
    
    // Menger 海绵 DE
    float3 mengerPos;
    float mengerDistance = MengerSpongeDE(fractalPos, mengerPos);
    
    // 谢尔宾斯基地形 DE
    float3 sierpinskiPos;
    float sierpinskiDistance = SierpinskiDE(fractalPos, sierpinskiPos);
    
    // 克莱因群 DE
    float3 kleinianPos;
    //float kleinianDistance = KleinianDE(fractalPos, minFractalPos, maxFractalPos, kleinianPos);
    float kleinianDistance = KleinianDE(fractalPos * sqrt(length(mandelbrotPos)), minFractalPos, maxFractalPos, kleinianPos);
    
    //minDistance = min(minDistance, quaternionJuliaDistance);
    //minDistance = min(minDistance, mandelbrotDistance);
    minDistance = min(minDistance, kleinianDistance);
    //minDistance = min(minDistance, juliaDistance);
    //minDistance = min(minDistance, amazingBoxDistance);
    //minDistance = min(minDistance, mandelbulbDistance);
    //minDistance = min(minDistance, mengerDistance);
    //minDistance = min(minDistance, sierpinskiDistance);

    return minDistance;
}

//---------------------------------------------------
// Main compute function
//---------------------------------------------------
[numthreads(8, 8, 8)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (any(id >= chunkSize))
        return; // 防止溢出（虽修复后 id<=35, chunk=34, 但保险）
    int index = id.z + id.y * chunkSize.z + id.x * (chunkSize.y * chunkSize.z);
    
    // Calculate world position based on logical size, with an offset for the padding.
    // 'chunkSize' is the padded size (e.g., 34), so logical size is 'chunkSize - 2'.
    // We offset the grid position by -1 to center the logical chunk correctly.
    uint3 logicalChunkSize = chunkSize - 2;
    int3 worldPos = (chunkPosition * (int3) logicalChunkSize) + int3(id) - 1;
    
    float3 fractalPos = float3(worldPos.x, -worldPos.z, worldPos.y) * 0.01;
    
    float4 minFractalPos = float4(-0.3252, -0.7862, -0.0948, 0.678);
    float4 maxFractalPos = float4(0.3457, 1.0218, 1.2215, 0.9);
    float dist = CombinedFractalDE(fractalPos, minFractalPos, maxFractalPos);
    
    int voxelID = 0; // Default to Air
    uint metadata = 0; // Default metadata
    
    // --- Default to generating Blocks ---
    if (dist < 0.0)
    {
        voxelID = 1; // Block ID 1 (e.g., Dirt/Stone)
    }
    if (fractalPos.x > 0)
    {
        voxelID = -1; // Block ID 1 (e.g., Dirt/Stone)
        float density = clamp(-dist, -1.0, 1.0);
        
        // 将 [-1, 1] 的密度映射到 [0, 255] 的 metadata
        metadata = (uint) (density * 127.0 + 128.0);
    }

    asyncVoxelBuffer[index].voxelID = voxelID;
    asyncVoxelBuffer[index].metadata = metadata;
}